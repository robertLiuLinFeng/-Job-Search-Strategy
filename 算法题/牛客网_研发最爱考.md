#### 网址: [牛客网_研发最爱考](https://www.nowcoder.com/ta/job-code-high-rd)

#### 目录

* 数组
    * [1.  字符串数组中的最长公共前缀](https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47?tpId=190&&tqId=35964&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)
    * [2. 调整数组元素顺序使得奇数位于偶数前面](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=190&&tqId=35985&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)
    * [3. 数组元素拼接成最大数](https://www.nowcoder.com/practice/fc897457408f4bbe9d3f87588f497729?tpId=190&&tqId=36031&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)
* 堆
    * [1. 随时找到数据流的中位数](https://www.nowcoder.com/practice/8c5e99acb1fa4bc3a342cd321100c0cd?tpId=190&&tqId=36009&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)
* 链表
* 动态规划
    * [1. 矩阵的最小路径和](https://www.nowcoder.com/practice/23462ed010024fcabb7dbd3df57c715e?tpId=190&&tqId=35189&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)
* 树与二叉树
    * [1. 二叉树的先序、中序、后序三种遍历方式的非递归写法](https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=190&&tqId=35221&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)
* 二分法
    * [1. 有重复数字的有序数组的二分查找](https://www.nowcoder.com/practice/7bc4a1c7c371425d9faa9d1b511fe193?tpId=190&&tqId=35227&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)
* 递归与回溯
    * [1. 解数独](https://www.nowcoder.com/practice/5e6c424b82224b85b64f28fd85761280?tpId=190&&tqId=35583&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)
* 并查集



### 数组

[1. 字符串数组中的最长公共前缀](https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47?tpId=190&&tqId=35964&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

假设ans为最长公共前缀，初始化ans = strs[0]:

1. 求ans与strs[i]的最长公共前缀
2. 更新ans，如果ans为空则结束
3. 如果没有遍历完数组中的所有字符串，则重复1. 2

```cpp
class Solution {
public:
    /**
     * 
     * @param strs string字符串vector 
     * @return string字符串
     */
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.size() == 0) {
            return "";
        }
        if(strs.size() == 1) {
            return strs[0];
        }
        
        string ans = strs[0];
        for(int i = 1; i < strs.size(); i++) {
            int j = 0;
            while(j < ans.length() && j < strs[i].length() && ans[j] == strs[i][j]) {
                j++;
            }
            ans = ans.substr(0, j);
            if(ans == "") {
                break;
            }
        }
        return ans;
    }
};
```

[2. 调整数组顺序使得奇数位于偶数前面](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=190&&tqId=35985&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

下面是一种空间换时间的思路，空间复杂度$O(n)$，时间复杂度$O(n)$。

```cpp
class Solution {
public:
    void reOrderArray(vector<int> &array) {
        // 先扫描array，获得奇数和偶数的个数
        int everCount = 0, oddCount = 0;
        for_each(array.begin(), array.end(), [&](int& n) {
            if(n % 2 == 0) {
                everCount++;
            }
            else {
                oddCount++;
            }
        });

        vector<int> copy_array(array.begin(), array.end());
        int i = 0, j = oddCount;
        for_each(copy_array.begin(), copy_array.end(), [&](int& n) {
            if(n % 2 == 0) {
                array[j++] = n;
            }
            else {
                array[i++] = n;
            }
        });
    }
};
```

[3. 数组元素拼接成最大数](https://www.nowcoder.com/practice/fc897457408f4bbe9d3f87588f497729?tpId=190&&tqId=36031&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

本质上是一个排序的问题，将a、b拼接成最大的数，则可以将a、b排序，使得a+b > b+a，然后拼接结果就是a+b了。

```cpp
class Solution {
public:
    string solve(vector<int>& nums) {
        vector<string> strs;
        for(auto& n: nums) {
            strs.push_back(to_string(n));
        }
        
        sort(strs.begin(), strs.end(), [](const string& a, const string& b) {
            return a+b > b+a;
        });
        
        string ans;
        for(auto& s: strs) {
            ans += s;
        }
        
        // 去除前导0, 但是要注意00去除前导0后结果为0，而不是为空
        while(ans.length() > 1 && ans[0] == '0') {
            ans.erase(ans.begin());
        }
        
        return ans;
    }
};
```







### 堆

[1. 随时找到数据流的中位数](https://www.nowcoder.com/practice/8c5e99acb1fa4bc3a342cd321100c0cd?tpId=190&&tqId=36009&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

假设数据流中已经出来了N个数，如果让我们手动找中位数的话，首先要对这N个数进行排序，然后根据N为奇数或者偶数选择中间的一个或者两个数来计算中位数。

我们取的中间的数把这N个数分成了两组，设为A、B。因为数组是经过排序的，所以我们可以假设A中元素全部小于B。所以，我们只要找到A中的最大值和B中的最小值。

**寻找最值，堆是最常用的数据结构。**

```cpp
class Solution {
    int count = 0;
    // 保证大顶堆中的元素 < 小顶堆中的元素
    priority_queue<int, vector<int>, less<int> > maxHeap;    // 大顶堆
    priority_queue<int, vector<int>, greater<int> > minHeap;    // 小顶堆
    
public:
    
    void put(int n) {
        if(count % 2 == 0) {
            // 添加到大顶堆中
            minHeap.push(n);
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
        else {
            // 添加到小顶堆中
            maxHeap.push(n);
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        }
        count++;
    }
    
    double get() {
        if(count == 0) {
            return -1;
        }
        
        if(count % 2 == 0) {
            int x = maxHeap.top(), y = minHeap.top();
            return (double)(x + y) / 2.0;
        }
        else {
            return (double)maxHeap.top();
        }
    }
    
    vector<double> flowmedian(vector<vector<int> >& operations) {
        vector<double> ans;
        for(auto& op: operations) {
            if(op[0] == 1) {
                put(op[1]);
            }
            else {
                ans.push_back(get());
            }
        }
        return ans;
    }
};
```





### 链表







### 动态规划

[1. 矩阵的最小路径和](https://www.nowcoder.com/practice/23462ed010024fcabb7dbd3df57c715e?tpId=190&&tqId=35189&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int> >& grid) {
        if(grid.size() == 0 || grid[0].size() == 0) {
            return 0;
        }
        int Rows = grid.size(), Cols = grid[0].size();
        // dp[i][j]表示从grid[0][0]到达grid[i][j]最小的路径
        vector<vector<int>> dp(Rows, vector<int>(Cols, 0));
        dp[0][0] = grid[0][0];
        // 第一行只能从左边到达
        for(int c = 1; c < Cols; c++) {
            dp[0][c] = dp[0][c-1] + grid[0][c];
        }
        // 第一列只能从上边到达
        for(int r = 1; r < Rows; r++) {
            dp[r][0] = dp[r-1][0] + grid[r][0];
        }
        
        for(int r = 1; r < Rows; r++) {
            for(int c = 1; c < Cols; c++) {
                dp[r][c] = std::min(dp[r-1][c], dp[r][c-1]) + grid[r][c];
            }
        }

        return dp[Rows-1][Cols-1];
    }
};
```







### 树与二叉树

[1. 二叉树的先序、中序、后序三种遍历方式的非递归写法](https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=190&&tqId=35221&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```cpp
// 先序遍历
void preOrders(TreeNode* root, vector<int>& ans) {
    stack<TreeNode*> st;
    TreeNode* p = root;
    while(p || !st.empty()) {
        if(p) {
            ans.push_back(p->val);
            st.push(p);
            p = p->left;
        }
        else {
            p = st.top()->right;
            st.pop();
        }
    }
}
```

```cpp
// 中序遍历
void onOrder(TreeNode* root, vector<int>& ans) {
	stack<TreeNode*> st;
	TreeNode* p = root;
        
	while(p || !st.empty()) {
		if(p) {
			st.push(p);
            p = p->left;
        }
        else {
            p = st.top();
            st.pop();
            ans.push_back(p->val);
            p = p->right;
        }
    }
}
```

```cpp
// 后序遍历
void postOrder(TreeNode *root, vector<int> &ans) {
	stack<pair<TreeNode *, bool>> st;
	if (root)
		st.push({root, false});

	while (!st.empty()) {
		auto& node = st.top();
		if (false == node.second) {
			node.second = true;
			if(node.first->right) {
				st.push({node.first->right, false});
			}
			if(node.first->left) {
				st.push({node.first->left, false});
			}
		}
		else {
			ans.push_back(node.first->val);
			st.pop();
		}
	}
}
```





### 二分法

[1. 有重复数字的有序数组的二分查找](https://www.nowcoder.com/practice/7bc4a1c7c371425d9faa9d1b511fe193?tpId=190&&tqId=35227&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```cpp
class Solution {
public:
    int upper_bound_(int n, int v, vector<int>& a) {
        int l = 0, r = n-1, mid, pos = -1;
        while(l <= r) {
            mid = l + (r - l) / 2;
            if(a[mid] >= v) {
                pos = mid;
                r = mid - 1;
            }
            else {
                l = mid + 1;
            }
        }
        // 注意要找的是位置，不是下标
        return pos == -1 ? n+1 : pos+1;
    }
};
```

### 单调队列

[1. 滑动窗口的最大值](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=190&&tqId=35991&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

维护一个单调队列，保证从队头到队尾单调递减，队头就是最大值。与普通队列不同的是，该单调队列是一个双端队列，队头和队尾都可以插入和删除元素。

```cpp
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size) {
        if(size > num.size()) {
            return {};
        }
        
        vector<int> ans, que(num.size(), 0);
        int head = 0, tail = 0;    // 指示队头和队尾
        // 第一个窗口
        for(int i = 0; i < size; i++) {
            while(head < tail && que[tail-1] < num[i]) {
                tail--;
            }
            que[tail++] = num[i];
        }
        
        int left = 0, right = size-1;    // 指示滑动窗口的两端
        while(right < num.size()) {
            // 队头是滑动窗口的最大值
            ans.push_back(que[head]);
            // 左边收缩一个元素
            if(head < tail && que[head] == num[left]) {
                head++;
            }
            left++;
            // 右边扩张一个元素
            if(right+1 < num.size()) {
                while(head < tail && que[tail-1] < num[right+1]) {
                    tail--;
                }
                que[tail++] = num[right+1];
            }
            right++;
        }
        return ans;
    }
};
```

### 递归与回溯

[1. 解数独](https://www.nowcoder.com/practice/5e6c424b82224b85b64f28fd85761280?tpId=190&&tqId=35583&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

数独的规则: 

* 同一行只能是1-9中的数，不能重复
* 同一列只能是1-9中的数，不能重复
* 同一个3\*3的小方格只能是1-9中的数，不能重复

第一个要解决的问题就是如何标定行、列、小方格中已经用过的数。

* row(i, j): 第i行中数字j使用了
* col(i, j): 第i列中数字j使用了
* grid(i, j, k): 在第(i, j)个小方格中数字k使用了

然后回溯就好了。

```cpp
class Solution {
public:
    // row[i][j]表示第i行中数字j用过了
    // col[i][j]表示第i列中数字j用过了
    // grid[i][j][k]表示方格[i][j]中数字j用过了
    bool row[9][10], col[9][10], grid[3][3][10];
    int Rows, Cols;
    
    bool dfs(int x, int y, vector<vector<char>>& board) {
        if(y == Cols) {
            // 一行处理完了，处理下一行
            x++;
            y = 0;
        }
        if(x == Rows) {
            // 所有的空格都填满了
            return true;
        }
        if(board[x][y] != '.') {
            // 如果[x][y]已经填了数字
            return dfs(x, y+1, board);
        }
        
        // 1-9挨个填
        for(int i = 1; i <= 9; i++) {
            if(!row[x][i] && !col[y][i] && !grid[x/3][y/3][i]) {
                // 填入数字i
                row[x][i] = col[y][i] = grid[x/3][y/3][i] = true;
                board[x][y] = i + '0';
                bool res = dfs(x, y+1, board);
                if(res) {
                    return true;
                }
                // 回溯
                row[x][i] = col[y][i] = grid[x/3][y/3][i] = false;
                board[x][y] = '.';
            }
        }
        return false;
    }
    
    void solveSudoku(vector<vector<char> > &board) {
        Rows = board.size();
        Cols = board[0].size();
        // 标定哪一些数字是用过的
        for(int x = 0; x < Rows; x++) {
            for(int y = 0; y < Cols; y++) {
                if(board[x][y] != '.') {
                    int num = board[x][y] - '0';
                    row[x][num] = col[y][num] = grid[x/3][y/3][num] = true;
                }
            }
        }
        dfs(0, 0, board);
    }
};
```



### 并查集